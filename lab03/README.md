# Lab3. Subway Surfers

In Lab 3, the task requires a protagonist to navigate a 4×64 map containing elements such as roads, lower obstacles, higher obstacles, and trains. The protagonist can explore the map using four actions: forward, left, right, and jump, with success defined as reaching the final column. I extended the FSM design from Lab 2, adopting a comprehensive flow of input, forward and backtrack searching, and result output to clarify the control logic and data flow. Notably, for the 4×64 map representation, I implemented the map progression using 4 shift registers instead of 4 large multiplexers. This avoids complex selection logic, effectively saves circuit area, and aligns the data movement behavior more closely with actual hardware operation.
<br>
<br>
This lab places greater emphasis on writing a functionally complete testbench rather than the RTL design itself. I employed random testing, generating a total of 300 test cases to verify the correctness of the RTL across various maps and initial conditions. The testbench automatically generates 4×64 map content according to specifications and simulates the protagonist's behavior. Additionally, as the project defines 10 distinct specs, my testbench must check the design against each one sequentially, ensuring the output meets both timing and functional requirements while rigorously verifying correctness and performance.
<br>
<br>
The core of this experiment focuses on the importance of verification within the VLSI design flow. From circuit design to actual manufacturing, the later a defect is discovered, the greater the loss in time and cost; therefore, a robust verification process is critical for risk mitigation. Regarding verification strategies, relying solely on random testing often makes it difficult to achieve 100% coverage. Consequently, directed testing is typically introduced in the later stages of verification to actively design test cases for specific corner cases, uncovering elusive bugs. The overall process can be categorized into preliminary verification, broad-spectrum verification, and corner-case verification, gradually expanding the test scope. During implementation, file I/O can be utilized alongside high-level languages to generate test data, while tasks and functions enhance the readability and maintainability of the testbench.
<br>
<br>
Furthermore, Verilog provides syntax related to timing checks, which is an area I hope to explore further. SystemVerilog offers convenient features such as SystemVerilog Assertions (SVA), random generation, and Object-Oriented Programming (OOP), allowing the verification environment to be more modular and scalable. Through this lab, I gained a more comprehensive and concrete understanding of the role of verification in practical IC design and personally realized that "a great hardware designer is also a great verifier." Effective verification is essential for designing functionally correct chips.

<p align="center"><img src="/images/subway_surfer.png" alt="subway surfer" width="840" /></p>
